<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack AI Solver</title>
    
     <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #1e2d2b; color: #f0f0f0; line-height: 1.6; }
        h1, h2, h3 { color: #2ecc71; text-align: center; margin-bottom: 20px; }
        #game-screen { display: grid; grid-template-columns: 2fr 3fr 2fr; gap: 20px; max-width: 1600px; margin: 20px auto; align-items: start; }
        
        /* Column Styles */
        .game-column { display: flex; flex-direction: column; gap: 20px; }

        /* --- STICKY COLUMNS --- */
        .game-column:nth-child(2),
        .game-column:nth-child(3) {
            position: -webkit-sticky;
            position: sticky;
            top: 20px;
        }

        /* Component Styles */
        #dealer-area, .player-card, #game-info, #input-controls, #ai-recommendation, #user-actions, #setup-screen {
            border: 1px solid #334b46; padding: 15px; border-radius: 8px; background-color: #2c3e3a;
        }
        .player-card { margin-bottom: 20px; min-height: 180px; position: relative; }
        #setup-screen { max-width: 500px; margin: 50px auto; display: flex; flex-direction: column; gap: 15px;}
        .player-card.active-player { border-color: #2ecc71; box-shadow: 0 0 15px rgba(46, 204, 113, 0.6); }
        .player-bet-recommendation { color: #f1c40f; font-weight: bold; text-align: center; margin-bottom: 10px; }
        
        /* --- STYLES FOR EMPTY SEATS & REMOVE BUTTON --- */
        .player-card.empty-seat {
            background-color: #253532;
            text-align: center;
            border-style: dashed;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .add-player-btn {
            background-color: #3498db;
            margin-top: 10px;
        }
        .add-player-btn:hover {
            background-color: #5dade2;
        }
        .remove-player-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #c0392b;
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .remove-player-btn:hover {
            background-color: #e74c3c;
        }
        /* --- END STYLES --- */

        /* Buttons and Inputs */
        button { padding: calc(10px * 1.3) calc(15px * 1.3); border: none; background-color: #27ae60; color: white; border-radius: 5px; cursor: pointer; margin: 5px; font-weight: bold; font-size: 1.3em; }
        button:hover { background-color: #2ecc71; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        select, input[type="number"], input[type="text"] { padding: 8px; margin: 5px; background-color: #1e2d2b; color: #f0f0f0; border: 1px solid #334b46; border-radius: 5px; }
        #next-hand-btn { background-color: #3498db; }
        #next-hand-btn:hover { background-color: #5dade2; }
        .setup-option { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        #bankroll-inputs-container { width: 100%; }

        /* --- STYLES FOR BANKROLL UPDATE --- */
        .bankroll-update-controls { display: none; margin-left: 10px; }
        .bankroll-update-controls .bankroll-input { width: 80px; padding: 4px; font-size: 0.9em; }
        .update-bankroll-btn { padding: 4px 8px; font-size: 0.8em; background-color: #3498db; }
        .update-bankroll-btn:hover { background-color: #5dade2; }

        /* Card Styles */
        .card { display: inline-block; width: 40px; height: 60px; line-height: 60px; text-align: center; padding: 10px; border: 1px solid #f0f0f0; border-radius: 6px; margin: 4px; font-weight: bold; background-color: #fff; color: #1e2d2b; font-size: 1.2em; }
        .player-hands-container { display: flex; flex-wrap: wrap; gap: 15px; }
        .hand { padding: 10px; border: 2px solid transparent; border-radius: 5px; min-width: 150px; }
        
        .hand.playable { cursor: pointer; border-color: #555; }
        .hand.playable:hover { background-color: #3f5b56; }
        .hand.active-hand { border-color: #3498db; background-color: #334b46; }

        /* Card Picker Styles */
        #card-picker-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; }
        .card-picker-card {
            height: 50px; line-height: 50px;
            text-align: center; font-size: 1.2em; font-weight: bold;
            border: 1px solid #f0f0f0; border-radius: 4px;
            background-color: #fff; color: #1e2d2b;
            cursor: pointer; user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .card-picker-card:hover { transform: scale(1.1); box-shadow: 0 0 10px #2ecc71; }
        .card-picker-card.disabled { opacity: 0.2; pointer-events: none; }
        
        #insurance-prompt { margin-top: 10px; padding: 10px; background-color: #334b46; border-left: 4px solid #f1c40f; }
        #recommendation-text { font-size: 1.5em; font-weight: bold; }
        #insurance-recommendation { font-size: 0.9em; }
        #current-action { font-size: 1.4em; }
        .player-status { font-weight: bold; font-size: 1.1em; color: #f1c40f; }
        #cancel-action-btn { background-color: #8e44ad; }
        #cancel-action-btn:hover { background-color: #a569bd; }
    </style>
</head>
<body>

    <div id="setup-screen">
        <h2>Game Setup</h2>
        <div class="setup-option">
            <label for="num-players">Number of Player Spots (1-7):</label>
            <input type="number" id="num-players" min="1" max="7" value="1">
        </div>
        <div class="setup-option">
            <label for="num-decks">Number of Decks (1-8):</label>
            <input type="number" id="num-decks" min="1" max="8" value="6">
        </div>
        <div class="setup-option">
            <label>Bankroll Type:</label>
            <div>
                <input type="radio" id="bankroll-uniform" name="bankroll-type" value="uniform" checked>
                <label for="bankroll-uniform" style="margin-right: 10px;">Uniform</label>
                <input type="radio" id="bankroll-individual" name="bankroll-type" value="individual">
                <label for="bankroll-individual">Individual</label>
            </div>
        </div>
        <div id="bankroll-inputs-container">
            </div>
        <div class="setup-option">
            <label for="min-bet">Minimum Bet:</label>
            <input type="number" id="min-bet" min="1" value="10">
        </div>
        <div class="setup-option">
            <label for="max-bet">Maximum Bet:</label>
            <input type="number" id="max-bet" min="1" placeholder="No limit">
        </div>
        <div class="setup-option">
            <label for="allow-surrender">Allow Surrender:</label>
            <input type="checkbox" id="allow-surrender" checked>
        </div>
        <div class="setup-option">
            <label for="soft-17-rule">Dealer on Soft 17:</label>
            <select id="soft-17-rule">
                <option value="stand" selected>Stands (S17)</option>
                <option value="hit">Hits (H17)</option>
            </select>
        </div>
        <button id="start-game-btn">Start Game</button>
    </div>

    <div id="game-screen" style="display:none;">
        <div class="game-column">
            <div id="game-info">
                <h3>Game Info</h3>
                <p><b id="info-label-1">Running Count:</b> <span id="info-value-1">0</span></p>
                <p><b id="info-label-2">True Count:</b> <span id="info-value-2">0.0</span></p>
                <p><b>Cards Seen:</b> <span id="cards-remaining">0</span></p>
            </div>
            <div id="players-area">
                </div>
        </div>

        <div class="game-column">
            <div id="dealer-area">
                <h3>Dealer's Hand</h3>
                <div id="dealer-cards"></div>
                <p>Value: <span id="dealer-value">0</span></p>
            </div>
            <div id="ai-recommendation">
                <h3>AI Recommendation</h3>
                <p id="recommendation-text">---</p>
                <div id="insurance-prompt" style="display:none;">
                    <p>Dealer has an Ace. The AI recommends: <b id="insurance-recommendation"></b></p>
                </div>
            </div>
             <div id="user-actions">
                <h3>User Actions</h3>
                <p id="current-action">Waiting to start hand...</p>
                <div>
                    <button class="action-btn" data-move="HIT">Hit</button>
                    <button class="action-btn" data-move="STAND">Stand</button>
                    <button class="action-btn" data-move="DOUBLE">Double</button>
                    <button class="action-btn" data-move="SPLIT">Split</button>
                    <button class="action-btn" data-move="SURRENDER">Surrender</button>
                </div>
                <div>
                    <button id="next-hand-btn" style="display:none;">Start Next Hand</button>
                </div>
            </div>
        </div>

        <div class="game-column">
             <div id="input-controls">
                <h3>Deal a Card (Click to select)</h3>
                <div id="card-picker-grid"></div>
            </div>
            <div>
                <button id="cancel-action-btn" disabled>Cancel Previous Action</button>
            </div>
        </div>
    </div>

    <p style="font-size: 1.2em; font-weight: bold; text-align: center;">Enjoying our software? Please consider supporting us with a donation.</p>
    <p style="font-size: 1.2em; font-weight: bold; text-align: center;">BTC address: bc1qgp6t9d9rfrfch0qhlzwsh6ppg9gaqtxpv3pvuz</p>

    <script type="module">
        // ========================================================================
        // CORE GAME LOGIC
        // ========================================================================
        const SUITS = ['♠', '♣', '♥', '♦'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.value = this._getValue(rank);
            }
            _getValue(rank) {
                if (['J', 'Q', 'K'].includes(rank)) return 10;
                if (rank === 'A') return 11;
                return parseInt(rank, 10);
            }
            toString() { return `${this.rank}${this.suit}`; }
        }

        class Hand {
            constructor() { this.cards = []; this.status = 'active'; }
            addCard(card) { this.cards.push(card); }
            getValue() {
                let value = this.cards.reduce((sum, card) => sum + card.value, 0);
                let aceCount = this.cards.filter(card => card.rank === 'A').length;
                while (value > 21 && aceCount > 0) { value -= 10; aceCount--; }
                return value;
            }
            isBlackjack() { return this.cards.length === 2 && this.getValue() === 21; }
            isBust() { return this.getValue() > 21; }
            isPair() { return this.cards.length === 2 && this.cards[0].rank === this.cards[1].rank; }
            isSoft() {
                const valueWithAceAs11 = this.cards.reduce((s, c) => s + c.value, 0);
                const hasAce = this.cards.some(c => c.rank === 'A');
                return hasAce && valueWithAceAs11 > this.getValue();
            }
        }

        class Player {
            constructor(id, initialBankroll = 1000) { this.id = id; this.bankroll = initialBankroll; this.reset(); }
            reset() { this.hands = [new Hand()]; this.bets = [0]; this.status = ''; }
            splitHand(handIndex) {
                const handToSplit = this.hands[handIndex];
                const newHand = new Hand();
                newHand.addCard(handToSplit.cards.pop());
                this.hands.push(newHand);
                this.bets.push(this.bets[handIndex]);
            }
        }

        // ========================================================================
        // AI: HI-LO CARD COUNTER
        // ========================================================================
        class HiLoCounter {
            constructor(numDecks = 6) {
                this.numDecks = numDecks;
                this.totalCards = numDecks * 52;
                this.reset();
            }
            reset() { this.runningCount = 0; this.cardsSeen = 0; }
            countCard(card) {
                this.cardsSeen++;
                if (card.value >= 2 && card.value <= 6) this.runningCount++;
                else if (card.value >= 10) this.runningCount--;
            }
            uncountCard(card) {
                this.cardsSeen--;
                if (card.value >= 2 && card.value <= 6) this.runningCount--;
                else if (card.value >= 10) this.runningCount++;
            }
            getTrueCount() {
                const decksRemaining = (this.totalCards - this.cardsSeen) / 52;
                return decksRemaining > 0 ? this.runningCount / decksRemaining : 0;
            }
        }
        
        // ========================================================================
        // AI: STRATEGY (BASIC STRATEGY + HI-LO DEVIATIONS)
        // ========================================================================
        const H = 'HIT', S = 'STAND', D = 'DOUBLE', P = 'SPLIT', R = 'SURRENDER';
        
        const hardTotals = {
        //   2  3  4  5  6  7  8  9  10 A
            20: [S, S, S, S, S, S, S, S, S, S], 19: [S, S, S, S, S, S, S, S, S, S],
            18: [S, S, S, S, S, S, S, S, S, S], 17: [S, S, S, S, S, S, S, S, S, S],
            16: [S, S, S, S, S, H, H, R, R, R], 15: [S, S, S, S, S, H, H, H, R, H],
            14: [S, S, S, S, S, H, H, H, H, H], 13: [S, S, S, S, S, H, H, H, H, H],
            12: [H, H, S, S, S, H, H, H, H, H], 11: [D, D, D, D, D, D, D, D, D, D],
            10: [D, D, D, D, D, D, D, D, H, H], 9:  [H, D, D, D, D, H, H, H, H, H],
            8:  [H, H, H, H, H, H, H, H, H, H],
        };
        const softTotals = {
        //   2  3  4  5  6  7  8  9  10 A
            20: [S, S, S, S, S, S, S, S, S, S], 19: [S, S, S, S, D, S, S, S, S, S],
            18: [D, D, D, D, D, S, S, H, H, H], 17: [H, D, D, D, D, H, H, H, H, H],
            16: [H, H, D, D, D, H, H, H, H, H], 15: [H, H, D, D, D, H, H, H, H, H],
            14: [H, H, H, D, D, H, H, H, H, H], 13: [H, H, H, D, D, H, H, H, H, H],
        };
        const pairs = {
        //   2  3  4  5  6  7  8  9  10 A
            'A': [P, P, P, P, P, P, P, P, P, P], '10':[S, S, S, S, S, S, S, S, S, S],
            '9': [P, P, P, P, P, S, P, P, S, S], '8': [P, P, P, P, P, P, P, P, P, P],
            '7': [P, P, P, P, P, P, H, H, H, H], '6': [P, P, P, P, P, H, H, H, H, H],
            '5': [D, D, D, D, D, D, D, D, H, H], '4': [H, H, H, P, P, H, H, H, H, H],
            '3': [P, P, P, P, P, P, H, H, H, H], '2': [P, P, P, P, P, P, H, H, H, H],
        };

        function getRecommendedMove(playerHand, dealerUpCard, counter, gameRules) {
            const playerValue = playerHand.getValue();
            const dealerValue = dealerUpCard.value;
            const trueCount = counter.getTrueCount();

            if (playerValue >= 21) return S;

            // ==============================================================
            // START: Illustrious 18 & Fab 4 Deviations Implementation
            // ==============================================================
            if (!playerHand.isPair() && playerValue === 16 && dealerValue === 10 && trueCount >= 0) return S;
            if (playerValue === 15 && dealerValue === 10 && trueCount >= 4) return S;
            if (playerValue === 12 && dealerValue === 3 && trueCount >= 2) return S;
            if (playerValue === 12 && dealerValue === 2 && trueCount >= 3) return S;
            if (!playerHand.isPair() && playerValue === 16 && dealerValue === 9 && trueCount >= 5) return S;
            if (playerValue === 13 && dealerValue === 2 && trueCount <= -1) return S;
            if (playerValue === 12 && dealerValue === 4 && trueCount <= 0) return S;
            if (playerValue === 12 && dealerValue === 5 && trueCount <= -2) return S;
            if (playerValue === 12 && dealerValue === 6 && trueCount <= -1) return S;
            if (playerValue === 13 && dealerValue === 3 && trueCount <= -2) return S;
            if (playerValue === 10 && dealerValue === 10 && trueCount >= 4) return D;
            if (playerValue === 11 && dealerValue === 11 && trueCount >= 1) return D;
            if (playerValue === 9 && dealerValue === 2 && trueCount >= 1) return D;
            if (playerValue === 10 && dealerValue === 11 && trueCount >= 4) return D;
            if (playerValue === 9 && dealerValue === 7 && trueCount >= 3) return D;
            if (playerHand.isPair() && playerHand.cards[0].value === 10 && dealerValue === 5 && trueCount >= 5) return P;
            if (playerHand.isPair() && playerHand.cards[0].value === 10 && dealerValue === 6 && trueCount >= 4) return P;
            if (gameRules.surrenderAllowed && playerHand.cards.length === 2) {
                if (playerValue === 14 && dealerValue === 10 && trueCount >= 3) return R;
                if (playerValue === 15 && dealerValue === 9 && trueCount >= 2) return R;
                if (playerValue === 15 && dealerValue === 11 && trueCount >= 1) return R;
            }
            // ==============================================================
            // END: Illustrious 18 & Fab 4 Deviations Implementation (4th deviation is already in Illustrious 18 rule 3)
            // ==============================================================
            
            const dealerIndex = dealerValue === 11 ? 9 : dealerValue - 2;
            let move;

            if (playerHand.isPair()) {
                move = pairs[playerHand.cards[0].rank][dealerIndex];
            } else if (playerHand.isSoft()) {
                 move = softTotals[playerValue] ? softTotals[playerValue][dealerIndex] : hardTotals[playerValue][dealerIndex];
            } else {
                if (playerValue <= 8) return H;
                move = hardTotals[playerValue][dealerIndex];
            }
            if (move === D && playerHand.cards.length > 2) return H;
            if (move === R && (!gameRules.surrenderAllowed || playerHand.cards.length > 2)) return H;
            return move;
        }

        // 18th Illustrious rule 18
        function shouldTakeInsurance(counter) { return counter.getTrueCount() >= 3; }

        function getBetAmount(counter, minBet, maxBet, bankroll) {
            const trueCount = counter.getTrueCount();
            let betUnits = trueCount >= 2 ? Math.floor(trueCount) : 1;
            const calculatedBet = betUnits * minBet;
            const finalBet = Math.min(calculatedBet, maxBet, bankroll / 4, bankroll);
            return Math.max(finalBet, minBet);
        }

        // ========================================================================
        // MAIN APPLICATION CONTROLLER
        // ========================================================================
        document.addEventListener('DOMContentLoaded', () => {
            const setupScreen = document.getElementById('setup-screen');
            const gameScreen = document.getElementById('game-screen');
            const recommendationText = document.getElementById('recommendation-text');
            const currentActionText = document.getElementById('current-action');
            const playersArea = document.getElementById('players-area');
            const startGameBtn = document.getElementById('start-game-btn');
            const nextHandBtn = document.getElementById('next-hand-btn');
            const cancelActionBtn = document.getElementById('cancel-action-btn');
            const userActionButtons = document.querySelectorAll('.action-btn');
            const insurancePrompt = document.getElementById('insurance-prompt');
            const insuranceRecommendation = document.getElementById('insurance-recommendation');
            const cardsRemainingSpan = document.getElementById('cards-remaining');
            const cardPickerGrid = document.getElementById('card-picker-grid');
            
            // Setup Screen Controls
            const numPlayersInput = document.getElementById('num-players');
            const bankrollTypeRadios = document.querySelectorAll('input[name="bankroll-type"]');

            let players = [], dealer = new Player('Dealer'), counter, gameState = 'SETUP';
            let currentPlayerIndex = 0, currentHandIndex = 0, dealingQueue = [];
            let gameRules = {};
            let previousStateStack = [];
            
            // --- Setup Screen Logic ---
            function updateBankrollSetupUI() {
                const container = document.getElementById('bankroll-inputs-container');
                const numPlayers = parseInt(numPlayersInput.value, 10) || 1;
                const isIndividual = document.getElementById('bankroll-individual').checked;
                container.innerHTML = ''; // Clear previous inputs

                if (isIndividual) {
                    for (let i = 0; i < numPlayers; i++) {
                        const div = document.createElement('div');
                        div.className = 'setup-option';
                        div.innerHTML = `
                            <label for="initial-bankroll-${i}">Player ${i + 1} Bankroll:</label>
                            <input type="number" id="initial-bankroll-${i}" value="1000" min="1">
                        `;
                        container.appendChild(div);
                    }
                } else {
                    const div = document.createElement('div');
                    div.className = 'setup-option';
                    div.innerHTML = `
                        <label for="initial-bankroll">Initial Bankroll for All:</label>
                        <input type="number" id="initial-bankroll" value="1000" min="1">
                    `;
                    container.appendChild(div);
                }
            }
            
            numPlayersInput.addEventListener('input', updateBankrollSetupUI);
            bankrollTypeRadios.forEach(radio => radio.addEventListener('change', updateBankrollSetupUI));
            updateBankrollSetupUI(); // Initial call to populate the form

            startGameBtn.addEventListener('click', initializeGame);
            nextHandBtn.addEventListener('click', startNewHand);
            userActionButtons.forEach(button => button.addEventListener('click', e => handleActionButtonClick(e.target.dataset.move)));
            cancelActionBtn.addEventListener('click', () => {
                if (previousStateStack.length === 0) return;
                const snapshot = previousStateStack.pop();
                restoreGameSnapshot(snapshot);
                cancelActionBtn.disabled = previousStateStack.length === 0;
            });
            
            playersArea.addEventListener('click', (event) => {
                if (event.target.classList.contains('add-player-btn')) {
                    addNewPlayer(parseInt(event.target.dataset.seatIndex, 10));
                } else if (event.target.classList.contains('remove-player-btn')) {
                    removePlayer(parseInt(event.target.dataset.seatIndex, 10));
                } else if (event.target.classList.contains('update-bankroll-btn')) {
                    const index = parseInt(event.target.dataset.playerIndex, 10);
                    const inputEl = playersArea.querySelector(`.bankroll-input[data-player-index="${index}"]`);
                    if (players[index] && inputEl) {
                        savePreviousState();
                        const newBankroll = parseInt(inputEl.value, 10);
                        if (!isNaN(newBankroll) && newBankroll >= 0) {
                            players[index].bankroll = newBankroll;
                            updateUI(); // Refresh UI to show updated value
                        }
                    }
                }
            });

            function savePreviousState() {
                previousStateStack.push(getGameSnapshot());
                cancelActionBtn.disabled = previousStateStack.length === 0;
            }

            function getGameSnapshot() {
                return {
                    gameState,
                    currentPlayerIndex,
                    currentHandIndex,
                    dealingQueue: dealingQueue.map(item => ({ ...item })),
                    gameRules: { ...gameRules },
                    counter: counter ? {
                        numDecks: counter.numDecks,
                        runningCount: counter.runningCount,
                        cardsSeen: counter.cardsSeen,
                    } : null,
                    players: players.map(player => player ? serializePlayer(player) : null),
                    dealer: dealer ? serializePlayer(dealer) : null,
                    ui: {
                        recommendationText: recommendationText.textContent,
                        currentActionText: currentActionText.textContent,
                        insurancePromptDisplay: insurancePrompt.style.display,
                        insuranceRecommendation: insuranceRecommendation.textContent,
                        nextHandBtnDisplay: nextHandBtn.style.display,
                        setupScreenDisplay: setupScreen.style.display,
                        gameScreenDisplay: gameScreen.style.display,
                    },
                };
            }

            function restoreGameSnapshot(snapshot) {
                gameState = snapshot.gameState;
                currentPlayerIndex = snapshot.currentPlayerIndex;
                currentHandIndex = snapshot.currentHandIndex;
                dealingQueue = snapshot.dealingQueue.map(item => ({ ...item }));
                gameRules = { ...snapshot.gameRules };

                if (snapshot.counter) {
                    counter = new HiLoCounter(snapshot.counter.numDecks);
                    counter.runningCount = snapshot.counter.runningCount;
                    counter.cardsSeen = snapshot.counter.cardsSeen;
                } else {
                    counter = null;
                }

                players = snapshot.players.map(player => player ? restorePlayer(player) : null);
                dealer = snapshot.dealer ? restorePlayer(snapshot.dealer) : new Player('Dealer');

                recommendationText.textContent = snapshot.ui.recommendationText;
                currentActionText.textContent = snapshot.ui.currentActionText;
                insurancePrompt.style.display = snapshot.ui.insurancePromptDisplay;
                insuranceRecommendation.textContent = snapshot.ui.insuranceRecommendation;
                nextHandBtn.style.display = snapshot.ui.nextHandBtnDisplay;
                setupScreen.style.display = snapshot.ui.setupScreenDisplay;
                gameScreen.style.display = snapshot.ui.gameScreenDisplay;

                createPlayerUI();
                updateUI();
            }

            function serializePlayer(player) {
                return {
                    id: player.id,
                    bankroll: player.bankroll,
                    hands: player.hands.map(hand => ({
                        cards: hand.cards.map(card => ({ rank: card.rank, suit: card.suit })),
                        status: hand.status,
                    })),
                    bets: [...player.bets],
                    status: player.status,
                };
            }

            function restorePlayer(data) {
                const player = new Player(data.id, data.bankroll);
                player.bankroll = data.bankroll;
                player.hands = data.hands.map(handData => {
                    const hand = new Hand();
                    hand.cards = handData.cards.map(card => new Card(card.suit, card.rank));
                    hand.status = handData.status;
                    return hand;
                });
                player.bets = [...data.bets];
                player.status = data.status;
                return player;
            }

            function addNewPlayer(seatIndex) {
                savePreviousState();
                // Find the first individual bankroll input to get a default value
                const defaultBankrollEl = document.getElementById('initial-bankroll-0') || document.getElementById('initial-bankroll');
                const initialBankroll = defaultBankrollEl ? (parseInt(defaultBankrollEl.value, 10) || 1000) : 1000;
                
                players[seatIndex] = new Player(`Player ${seatIndex + 1}`, initialBankroll);

                if (gameState === 'BETTING') {
                    const newPlayer = players[seatIndex];
                    const betAmount = getBetAmount(counter, gameRules.minBet, gameRules.maxBet, newPlayer.bankroll);
                    newPlayer.bets[0] = betAmount;
                    newPlayer.bankroll -= betAmount;
                    buildDealingQueue();
                    if (dealingQueue.length > 0) {
                        currentActionText.textContent = dealingQueue[0].message;
                    }
                }
                createPlayerUI();
                updateUI();
            }

            function removePlayer(seatIndex) {
                const playerToRemove = players[seatIndex];
                if (!playerToRemove) return;
                if (gameState !== 'BETTING' && gameState !== 'SETTLEMENT') return;

                savePreviousState();
                const betAmount = playerToRemove.bets.reduce((sum, bet) => sum + bet, 0);
                playerToRemove.bankroll += betAmount;
                players[seatIndex] = null;

                buildDealingQueue();
                currentActionText.textContent = dealingQueue.length > 0 ? dealingQueue[0].message : 'All players left. Add a player to begin.';
                
                createPlayerUI();
                updateUI();
            }

            function initializeGame() {
                const numPlayers = parseInt(numPlayersInput.value, 10);
                const numDecks = parseInt(document.getElementById('num-decks').value, 10);
                const minBet = parseInt(document.getElementById('min-bet').value, 10);
                const maxBetInput = document.getElementById('max-bet').value;
                const maxBet = maxBetInput ? parseInt(maxBetInput, 10) : Infinity;
                
                gameRules = { 
                    minBet, maxBet, 
                    surrenderAllowed: document.getElementById('allow-surrender').checked, 
                    dealerHitsOnSoft17: document.getElementById('soft-17-rule').value === 'hit' 
                };

                counter = new HiLoCounter(numDecks);
                
                // Initialize players with correct bankrolls based on setup choice
                const isIndividual = document.getElementById('bankroll-individual').checked;
                players = Array.from({ length: numPlayers }, (_, i) => {
                    let bankroll;
                    if (isIndividual) {
                        const inputEl = document.getElementById(`initial-bankroll-${i}`);
                        bankroll = inputEl ? parseInt(inputEl.value, 10) : 1000;
                    } else {
                        const inputEl = document.getElementById('initial-bankroll');
                        bankroll = inputEl ? parseInt(inputEl.value, 10) : 1000;
                    }
                    return new Player(`Player ${i + 1}`, bankroll || 1000);
                });

                dealer = new Player('Dealer');
                
                document.querySelector('[data-move="SURRENDER"]').style.display = gameRules.surrenderAllowed ? 'inline-block' : 'none';
                setupScreen.style.display = 'none';
                gameScreen.style.display = 'grid';
                createCardPicker();
                startNewHand();
            }
            
            function createCardPicker() {
                cardPickerGrid.innerHTML = '';
                RANKS.forEach(rank => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card-picker-card';
                    cardEl.textContent = rank;
                    cardEl.dataset.rank = rank;
                    cardEl.addEventListener('click', () => handleCardPickerClick(rank));
                    cardPickerGrid.appendChild(cardEl);
                });
            }

            function handleHandClick(event) {
                const handEl = event.currentTarget;
                const pIndex = parseInt(handEl.dataset.pIndex, 10);
                const hIndex = parseInt(handEl.dataset.hIndex, 10);

                if (pIndex !== currentPlayerIndex || gameState !== 'PLAYER_TURN') return;
                
                const hand = players[pIndex].hands[hIndex];
                if (hand.status !== 'active') return; 

                currentHandIndex = hIndex;
                startPlayerTurn();
            }

            function handleCardPickerClick(rank) {
                savePreviousState();
                if (gameState === 'BETTING') {
                    gameState = 'DEALING';
                }

                const cardToDeal = new Card('♠', rank);
                counter.countCard(cardToDeal);
                if (gameState === 'DEALING') {
                    const dealInfo = dealingQueue.shift();
                    if (!dealInfo) return;
                    const target = dealInfo.isDealer ? dealer : players[dealInfo.playerIndex];
                    target.hands[dealInfo.handIndex || 0].addCard(cardToDeal);
                    processDealingQueue();
                } else if (gameState === 'PLAYER_TURN') {
                    const hand = players[currentPlayerIndex].hands[currentHandIndex];
                    hand.addCard(cardToDeal);
                    if (hand.status === 'doubled' || hand.getValue() >= 21) {
                        if (hand.isBust()) hand.status = 'bust';
                        advanceTurn();
                    } else { startPlayerTurn(); }
                } else if (gameState === 'DEALER_TURN') {
                    dealer.hands[0].addCard(cardToDeal);
                    startDealerTurn(); 
                }
            }
            
            function handleActionButtonClick(move) {
                const player = players[currentPlayerIndex];
                if (!player || gameState !== 'PLAYER_TURN') return;
                const hand = player.hands[currentHandIndex];
                if (!hand) return;
                
                savePreviousState();
                switch (move) {
                    case 'HIT':
                        currentActionText.textContent = `Player hits on Hand ${currentHandIndex + 1}. Select dealt card.`;
                        break;
                    case 'STAND': hand.status = 'stand'; advanceTurn(); break;
                    case 'DOUBLE':
                        player.bankroll -= player.bets[currentHandIndex];
                        player.bets[currentHandIndex] *= 2;
                        hand.status = 'doubled';
                        currentActionText.textContent = `Player doubled on Hand ${currentHandIndex + 1}. Deal ONE card.`;
                        break;
                    case 'SPLIT':
                        player.bankroll -= player.bets[currentHandIndex];
                        player.splitHand(currentHandIndex);
                        startPlayerTurn();
                        break;
                    case 'SURRENDER':
                        if (hand.cards.length === 2 && gameRules.surrenderAllowed) { hand.status = 'surrendered'; advanceTurn(); } 
                        else { recommendationText.textContent = "Cannot surrender now."; }
                        break;
                }
                updateUI();
            }

            function startNewHand() {
                savePreviousState();
                gameState = 'BETTING';
                nextHandBtn.style.display = 'none'; insurancePrompt.style.display = 'none';
                players.forEach(p => { if (p) p.reset(); });
                dealer.reset();
                createPlayerUI();
                recommendationText.textContent = '---';

                players.forEach((p, i) => { 
                    if (!p) return;
                    const betAmount = getBetAmount(counter, gameRules.minBet, gameRules.maxBet, p.bankroll);
                    p.bets[0] = betAmount; 
                    p.bankroll -= betAmount;
                    const playerCard = document.getElementById(`player-${p.id.replace(/ /g, '-')}`);
                    if(playerCard) {
                        const recElement = playerCard.querySelector('.player-bet-recommendation');
                        if (recElement) recElement.textContent = `AI Recommended Bet: ${betAmount}`;
                    }
                });
                buildDealingQueue();
                processDealingQueue();
                updateUI(); 
            }

            function buildDealingQueue() {
                dealingQueue = [];
                players.forEach((p, i) => { if (p) dealingQueue.push({ playerIndex: i, handIndex: 0, message: `Deal first card to Player ${i + 1}` }); });
                dealingQueue.push({ isDealer: true, message: `Deal dealer's UP card` });
                players.forEach((p, i) => { if (p) dealingQueue.push({ playerIndex: i, handIndex: 0, message: `Deal second card to Player ${i + 1}` }); });
            }

            function processDealingQueue() {
                if (dealingQueue.length > 0) {
                    currentActionText.textContent = dealingQueue[0].message;
                    updateUI();
                } else { 
                    postDealCheck(); 
                }
            }

            function postDealCheck() {
                if (dealer.hands[0].cards.length > 0 && dealer.hands[0].cards[0].rank === 'A') {
                    insurancePrompt.style.display = 'block';
                    insuranceRecommendation.textContent = shouldTakeInsurance(counter) ? "TAKE Insurance" : "DO NOT Take Insurance";
                }
                currentPlayerIndex = 0; currentHandIndex = 0;
                startPlayerTurn();
            }

            function startPlayerTurn() {
                while(currentPlayerIndex < players.length && !players[currentPlayerIndex]) {
                    currentPlayerIndex++;
                }

                if (currentPlayerIndex >= players.length) { startDealerTurn(); return; }
                
                gameState = 'PLAYER_TURN';
                const player = players[currentPlayerIndex];
                const hand = player.hands[currentHandIndex];
                
                updateUI(); 

                if(!hand || hand.status !== 'active') { advanceTurn(); return; }
                
                if (hand.cards.length === 1) { 
                    currentActionText.textContent = `Player ${player.id}, Hand ${currentHandIndex + 1}: Please deal a card.`;
                    return;
                }
                
                if (hand.getValue() >= 21) {
                    if (hand.isBlackjack()) hand.status = 'blackjack';
                    else if (hand.isBust()) hand.status = 'bust';
                    advanceTurn(); return;
                }
                
                const move = getRecommendedMove(hand, dealer.hands[0].cards[0], counter, gameRules);
                recommendationText.textContent = `AI recommends: ${move}`;
                currentActionText.textContent = `Player ${player.id}, Hand ${currentHandIndex + 1}: Waiting for user action.`;
            }
            
            function advanceTurn() {
                const player = players[currentPlayerIndex];
                if (!player) { 
                    startDealerTurn(); 
                    return; 
                }

                const nextActiveHandIndex = player.hands.findIndex(hand => hand.status === 'active');

                if (nextActiveHandIndex !== -1) {
                    currentHandIndex = nextActiveHandIndex;
                    startPlayerTurn();
                } else {
                    currentPlayerIndex++;
                    currentHandIndex = 0;
                    startPlayerTurn(); 
                }
            }

            function startDealerTurn() {
                gameState = 'DEALER_TURN';
                recommendationText.textContent = '---';
                if (dealer.hands[0].cards.length < 2) {
                    currentActionText.textContent = `All players finished. Deal dealer's hole card.`;
                } else {
                    const dealerHand = dealer.hands[0];
                    const dealerValue = dealerHand.getValue();
                    let dealerStands = false;
                    if (dealerValue > 17 || (dealerValue === 17 && !dealerHand.isSoft()) || (dealerValue === 17 && dealerHand.isSoft() && !gameRules.dealerHitsOnSoft17)) {
                        dealerStands = true;
                    }

                    if (dealerHand.isBlackjack()) {
                        currentActionText.textContent = `Dealer has Blackjack.`;
                        settleBets();
                    } else if (dealerHand.isBust()) {
                         currentActionText.textContent = `Dealer busts with ${dealerValue}.`;
                         settleBets();
                    }
                    else if (dealerStands) {
                        currentActionText.textContent = `Dealer stands with ${dealerValue}.`;
                        settleBets();
                    } else {
                        currentActionText.textContent = `Dealer hits. Input next dealer card.`;
                    }
                }
                updateUI();
            }

            function settleBets() {
                gameState = 'SETTLEMENT';
                const dealerHand = dealer.hands[0];
                const dealerValue = dealerHand.isBust() ? 0 : dealerHand.getValue();
                
                players.forEach((player, index) => {
                    if (!player) return;

                    let totalPayout = 0;
                    player.hands.forEach((hand, hIndex) => {
                        const bet = player.bets[hIndex];
                        if (hand.status === 'surrendered') { totalPayout += bet / 2; return; }
                        const playerValue = hand.isBust() ? 0 : hand.getValue();
                        if (hand.isBlackjack() && !dealerHand.isBlackjack()) { totalPayout += bet * 2.5; hand.status = "WIN (BJ)"; }
                        else if (playerValue > 0 && (dealerValue === 0 || playerValue > dealerValue)) { totalPayout += bet * 2; hand.status = "WIN"; }
                        else if (playerValue > 0 && playerValue === dealerValue && !dealerHand.isBlackjack()) { totalPayout += bet; hand.status = "PUSH"; }
                        else { hand.status = "LOSE"; }
                    });
                    player.bankroll += totalPayout;

                    if (player.bankroll <= 0) {
                        console.log(`Player ${player.id} has busted out.`);
                        players[index] = null;
                    }
                });

                currentActionText.textContent = 'Bets settled. Empty seats are now open.';
                nextHandBtn.style.display = 'inline-block';
                
                createPlayerUI();
                updateUI();
            }
            
            function createPlayerUI() {
                playersArea.innerHTML = '';
                players.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-card';

                    if (player) {
                        playerDiv.id = `player-${player.id.replace(/ /g, '-')}`;
                        playerDiv.innerHTML = `
                            <button class="remove-player-btn" data-seat-index="${index}" title="Remove Player">✖</button>
                            <h3>${player.id}</h3>
                            <div class="player-bet-recommendation"></div>
                            <div class="player-hands-container"></div>
                            <p>
                                Bankroll: <span class="player-bankroll">${Math.round(player.bankroll)}</span>
                                <span class="bankroll-update-controls">
                                    <input type="number" class="bankroll-input" value="${Math.round(player.bankroll)}" data-player-index="${index}">
                                    <button class="update-bankroll-btn" data-player-index="${index}">Update</button>
                                </span>
                            </p>`;
                    } else {
                        playerDiv.classList.add('empty-seat');
                        playerDiv.id = `seat-${index}`;
                        playerDiv.innerHTML = `
                            <h3>Seat ${index + 1} (Empty)</h3>
                            <button class="add-player-btn" data-seat-index="${index}">Add New Player</button>
                        `;
                    }
                    playersArea.appendChild(playerDiv);
                });
            }

            function updateUI() {
                updateInfo();
                document.getElementById('dealer-value').textContent = dealer.hands[0].getValue();
                document.querySelector('#dealer-area #dealer-cards').innerHTML = dealer.hands[0].cards.map(c => `<span class="card">${c.rank}</span>`).join(' ');
                
                const showControls = (gameState === 'SETTLEMENT' || gameState === 'BETTING');

                players.forEach((player, pIndex) => {
                    if (!player) return;
                    const playerDiv = document.getElementById(`player-${player.id.replace(/ /g, '-')}`);
                    if (!playerDiv) return;
                    playerDiv.classList.toggle('active-player', pIndex === currentPlayerIndex && (gameState === 'PLAYER_TURN' || gameState === 'DEALING'));
                    playerDiv.querySelector('.player-bankroll').textContent = Math.round(player.bankroll);
                    
                    const updateControls = playerDiv.querySelector('.bankroll-update-controls');
                    if(updateControls) {
                        updateControls.style.display = showControls ? 'inline' : 'none';
                    }
                    
                    const handsContainer = playerDiv.querySelector('.player-hands-container');
                    handsContainer.innerHTML = player.hands.map((hand, hIndex) => {
                        const isPlayerTurn = pIndex === currentPlayerIndex && gameState === 'PLAYER_TURN';
                        const isPlayable = isPlayerTurn && hand.status === 'active';
                        const isActiveHand = isPlayable && hIndex === currentHandIndex;

                        return `
                        <div class="hand ${isActiveHand ? 'active-hand' : ''} ${isPlayable ? 'playable' : ''}" 
                             data-p-index="${pIndex}" data-h-index="${hIndex}">
                            <div>${hand.cards.map(c => `<span class="card">${c.rank}</span>`).join(' ')}</div>
                            <p>Bet: ${player.bets[hIndex]} | Val: ${hand.getValue()} | Status: <span class="player-status">${hand.status}</span></p>
                        </div>`;
                    }).join('');

                    handsContainer.querySelectorAll('.hand.playable').forEach(handEl => {
                        handEl.addEventListener('click', handleHandClick);
                    });
                });

                document.querySelectorAll('.remove-player-btn').forEach(btn => {
                    btn.style.display = showControls ? 'inline-block' : 'none';
                });
            }

            function updateInfo() {
                if (!counter) return;
                document.getElementById('info-value-1').textContent = counter.runningCount;
                document.getElementById('info-value-2').textContent = counter.getTrueCount().toFixed(1);
                cardsRemainingSpan.textContent = counter.cardsSeen;
            }
        });
    </script>

</body>
</html>
