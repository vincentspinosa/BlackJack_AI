<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack AI Solver</title>
    
     <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #1e2d2b; color: #f0f0f0; line-height: 1.6; }
        h1, h2, h3 { color: #2ecc71; text-align: center; margin-bottom: 20px; }
        #game-screen { display: grid; grid-template-columns: 2fr 3fr 2fr; gap: 20px; max-width: 1600px; margin: 20px auto; align-items: start; }
        
        /* Column Styles */
        .game-column { display: flex; flex-direction: column; gap: 20px; }

        /* --- STICKY COLUMNS --- */
        .game-column:nth-child(2),
        .game-column:nth-child(3) {
            position: -webkit-sticky;
            position: sticky;
            top: 20px;
        }

        /* Component Styles */
        #dealer-area, .player-card, #game-info, #input-controls, #ai-recommendation, #user-actions, #setup-screen {
            border: 1px solid #334b46; padding: 15px; border-radius: 8px; background-color: #2c3e3a;
        }
        .player-card { margin-bottom: 20px; min-height: 180px; position: relative; }
        #setup-screen { max-width: 500px; margin: 50px auto; display: flex; flex-direction: column; gap: 15px;}
        .player-card.active-player { border-color: #2ecc71; box-shadow: 0 0 15px rgba(46, 204, 113, 0.6); }
        .player-bet-recommendation { color: #f1c40f; font-weight: bold; text-align: center; margin-bottom: 10px; }
        
        /* --- STYLES FOR EMPTY SEATS & REMOVE BUTTON --- */
        .player-card.empty-seat {
            background-color: #253532;
            text-align: center;
            border-style: dashed;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .add-player-btn {
            background-color: #3498db;
            margin-top: 10px;
        }
        .add-player-btn:hover {
            background-color: #5dade2;
        }
        .remove-player-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #c0392b;
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .remove-player-btn:hover {
            background-color: #e74c3c;
        }
        /* --- END STYLES --- */

        /* Buttons and Inputs */
        button { padding: calc(10px * 1.3) calc(15px * 1.3); border: none; background-color: #27ae60; color: white; border-radius: 5px; cursor: pointer; margin: 5px; font-weight: bold; font-size: 1.3em; }
        button:hover { background-color: #2ecc71; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        select, input[type="number"], input[type="text"] { padding: 8px; margin: 5px; background-color: #1e2d2b; color: #f0f0f0; border: 1px solid #334b46; border-radius: 5px; }
        #next-hand-btn { background-color: #3498db; }
        #next-hand-btn:hover { background-color: #5dade2; }
        .setup-option { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        #bankroll-inputs-container { width: 100%; }

        /* --- STYLES FOR BANKROLL UPDATE --- */
        .bankroll-update-controls { display: none; margin-left: 10px; }
        .bankroll-update-controls .bankroll-input { width: 80px; padding: 4px; font-size: 0.9em; }
        .update-bankroll-btn { padding: 4px 8px; font-size: 0.8em; background-color: #3498db; }
        .update-bankroll-btn:hover { background-color: #5dade2; }

        /* Card Styles */
        .card { display: inline-block; width: 40px; height: 60px; line-height: 60px; text-align: center; padding: 10px; border: 1px solid #f0f0f0; border-radius: 6px; margin: 4px; font-weight: bold; background-color: #fff; color: #1e2d2b; font-size: 1.2em; }
        .player-hands-container { display: flex; flex-wrap: wrap; gap: 15px; }
        .hand { padding: 10px; border: 2px solid transparent; border-radius: 5px; min-width: 150px; }
        
        .hand.playable { cursor: pointer; border-color: #555; }
        .hand.playable:hover { background-color: #3f5b56; }
        .hand.active-hand { border-color: #3498db; background-color: #334b46; }

        /* Card Picker Styles */
        #card-picker-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; }
        .card-picker-card {
            height: 50px; line-height: 50px;
            text-align: center; font-size: 1.2em; font-weight: bold;
            border: 1px solid #f0f0f0; border-radius: 4px;
            background-color: #fff; color: #1e2d2b;
            cursor: pointer; user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .card-picker-card:hover { transform: scale(1.1); box-shadow: 0 0 10px #2ecc71; }
        .card-picker-card.disabled { opacity: 0.2; pointer-events: none; }
        
        #insurance-prompt { margin-top: 10px; padding: 10px; background-color: #334b46; border-left: 4px solid #f1c40f; }
        #recommendation-text { font-size: 1.5em; font-weight: bold; }
        #insurance-recommendation { font-size: 0.9em; }
        #current-action { font-size: 1.4em; }
        .player-status { font-weight: bold; font-size: 1.1em; color: #f1c40f; }
        #cancel-action-btn { background-color: #8e44ad; }
        #cancel-action-btn:hover { background-color: #a569bd; }
    </style>
</head>
<body>

    <div id="setup-screen">
        <h2>Game Setup</h2>
        <div class="setup-option">
            <label for="num-players">Number of Player Spots (1-7):</label>
            <input type="number" id="num-players" min="1" max="7" value="1">
        </div>
        <div class="setup-option">
            <label for="num-decks">Number of Decks (1-8):</label>
            <input type="number" id="num-decks" min="1" max="8" value="6">
        </div>
        <div class="setup-option">
            <label>Bankroll Type:</label>
            <div>
                <input type="radio" id="bankroll-uniform" name="bankroll-type" value="uniform" checked>
                <label for="bankroll-uniform" style="margin-right: 10px;">Uniform</label>
                <input type="radio" id="bankroll-individual" name="bankroll-type" value="individual">
                <label for="bankroll-individual">Individual</label>
            </div>
        </div>
        <div id="bankroll-inputs-container">
            </div>
        <div class="setup-option">
            <label for="min-bet">Minimum Bet:</label>
            <input type="number" id="min-bet" min="1" value="10">
        </div>
        <div class="setup-option">
            <label for="max-bet">Maximum Bet:</label>
            <input type="number" id="max-bet" min="1" placeholder="No limit">
        </div>
        <div class="setup-option">
            <label for="surrender-type">Surrender:</label>
            <select id="surrender-type">
                <option value="none">Not Allowed</option>
                <option value="late" selected>Late Surrender</option>
                <option value="early">Early Surrender</option>
            </select>
        </div>
        <div class="setup-option">
            <label for="soft-17-rule">Dealer on Soft 17:</label>
            <select id="soft-17-rule">
                <option value="stand" selected>Stands (S17)</option>
                <option value="hit">Hits (H17)</option>
            </select>
        </div>
        <div class="setup-option">
            <label for="allow-das">Double After Split (DAS):</label>
            <input type="checkbox" id="allow-das" checked>
        </div>
        <div class="setup-option">
            <label for="allow-resplit-aces">Resplit Aces:</label>
            <input type="checkbox" id="allow-resplit-aces">
        </div>
        <div class="setup-option">
            <label for="hit-split-aces">Hit Split Aces:</label>
            <input type="checkbox" id="hit-split-aces">
        </div>
        <div class="setup-option">
            <label for="blackjack-payout">Blackjack Payout:</label>
            <select id="blackjack-payout">
                <option value="1.5" selected>3:2</option>
                <option value="1.2">6:5</option>
            </select>
        </div>
        <div class="setup-option">
            <label for="cut-card-penetration">Cut Card Penetration (%):</label>
            <input type="number" id="cut-card-penetration" min="50" max="95" value="75">
        </div>
        <button id="start-game-btn">Start Game</button>
    </div>

    <div id="game-screen" style="display:none;">
        <div class="game-column">
            <div id="game-info">
                <h3>Game Info</h3>
                <p><b id="info-label-1">Running Count:</b> <span id="info-value-1">0</span></p>
                <p><b id="info-label-2">True Count:</b> <span id="info-value-2">0.0</span></p>
                <p><b>Cards Remaining:</b> <span id="cards-remaining">0</span></p>
                <p><b>Penetration:</b> <span id="penetration-value">0%</span></p>
            </div>
            <div id="players-area">
                </div>
        </div>

        <div class="game-column">
            <div id="dealer-area">
                <h3>Dealer's Hand</h3>
                <div id="dealer-cards"></div>
                <p>Value: <span id="dealer-value">0</span></p>
            </div>
            <div id="ai-recommendation">
                <h3>AI Recommendation</h3>
                <p id="recommendation-text">---</p>
                <p id="recommendation-ev" style="font-size: 0.9em; color: #b2bec3;">EVs: --</p>
                <div id="insurance-prompt" style="display:none;">
                    <p>Dealer has an Ace. The AI recommends: <b id="insurance-recommendation"></b></p>
                </div>
            </div>
             <div id="user-actions">
                <h3>User Actions</h3>
                <p id="current-action">Waiting to start hand...</p>
                <div>
                    <button class="action-btn" data-move="HIT">Hit</button>
                    <button class="action-btn" data-move="STAND">Stand</button>
                    <button class="action-btn" data-move="DOUBLE">Double</button>
                    <button class="action-btn" data-move="SPLIT">Split</button>
                    <button class="action-btn" data-move="SURRENDER">Surrender</button>
                </div>
                <div>
                    <button id="next-hand-btn" style="display:none;">Start Next Hand</button>
                </div>
            </div>
        </div>

        <div class="game-column">
             <div id="input-controls">
                <h3>Deal a Card (Click to select)</h3>
                <div id="card-picker-grid"></div>
            </div>
            <div>
                <button id="cancel-action-btn" disabled>Cancel Previous Action</button>
            </div>
        </div>
    </div>

    <p style="font-size: 1.2em; font-weight: bold; text-align: center;">Enjoying our software? Please consider supporting us with a donation.</p>
    <p style="font-size: 1.2em; font-weight: bold; text-align: center;">BTC address: bc1qgp6t9d9rfrfch0qhlzwsh6ppg9gaqtxpv3pvuz</p>

    <script type="module">
        // ========================================================================
        // CORE GAME LOGIC
        // ========================================================================
        const SUITS = ['♠', '♣', '♥', '♦'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.value = this._getValue(rank);
            }
            _getValue(rank) {
                if (['J', 'Q', 'K'].includes(rank)) return 10;
                if (rank === 'A') return 11;
                return parseInt(rank, 10);
            }
            toString() { return `${this.rank}${this.suit}`; }
        }

        class Hand {
            constructor() {
                this.cards = [];
                this.status = 'active';
                this.fromSplit = false;
                this.splitDepth = 0;
                this.isSplitAce = false;
            }
            addCard(card) { this.cards.push(card); }
            getValue() {
                let value = this.cards.reduce((sum, card) => sum + card.value, 0);
                let aceCount = this.cards.filter(card => card.rank === 'A').length;
                while (value > 21 && aceCount > 0) { value -= 10; aceCount--; }
                return value;
            }
            isBlackjack() { return this.cards.length === 2 && this.getValue() === 21; }
            isBust() { return this.getValue() > 21; }
            isPair() { return this.cards.length === 2 && this.cards[0].rank === this.cards[1].rank; }
            isSoft() {
                const valueWithAceAs11 = this.cards.reduce((s, c) => s + c.value, 0);
                const hasAce = this.cards.some(c => c.rank === 'A');
                return hasAce && valueWithAceAs11 > this.getValue();
            }
        }

        class Player {
            constructor(id, initialBankroll = 1000) { this.id = id; this.bankroll = initialBankroll; this.reset(); }
            reset() { this.hands = [new Hand()]; this.bets = [0]; this.status = ''; }
            splitHand(handIndex) {
                const handToSplit = this.hands[handIndex];
                const newHand = new Hand();
                newHand.addCard(handToSplit.cards.pop());
                const isAceSplit = newHand.cards[0].rank === 'A';
                const splitDepth = handToSplit.splitDepth + 1;
                newHand.fromSplit = true;
                newHand.splitDepth = splitDepth;
                newHand.isSplitAce = isAceSplit;
                handToSplit.fromSplit = true;
                handToSplit.splitDepth = splitDepth;
                handToSplit.isSplitAce = isAceSplit;
                this.hands.push(newHand);
                this.bets.push(this.bets[handIndex]);
            }
        }

        // ========================================================================
        // SHOE + AI: HI-LO CARD COUNTER
        // ========================================================================
        class Shoe {
            constructor(numDecks = 6, penetration = 0.75) {
                this.numDecks = numDecks;
                this.totalCards = numDecks * 52;
                this.penetration = penetration;
                this.reset();
            }
            reset() {
                this.counts = {};
                RANKS.forEach(rank => {
                    const perDeck = rank === '10' ? 16 : 4;
                    this.counts[rank] = perDeck * this.numDecks;
                });
                this.cardsRemaining = this.totalCards;
                this.cutCardPosition = Math.max(0, Math.floor(this.totalCards * (1 - this.penetration)));
            }
            clone() {
                const clone = new Shoe(this.numDecks, this.penetration);
                clone.counts = { ...this.counts };
                clone.cardsRemaining = this.cardsRemaining;
                clone.cutCardPosition = this.cutCardPosition;
                return clone;
            }
            canDraw(rank) {
                return this.counts[rank] > 0;
            }
            drawRank(rank) {
                if (!this.canDraw(rank)) return false;
                this.counts[rank] -= 1;
                this.cardsRemaining -= 1;
                return true;
            }
            returnRank(rank) {
                this.counts[rank] = (this.counts[rank] || 0) + 1;
                this.cardsRemaining += 1;
            }
            shouldShuffle() {
                return this.cardsRemaining <= this.cutCardPosition;
            }
            getPenetrationPercent() {
                const dealt = this.totalCards - this.cardsRemaining;
                return this.totalCards > 0 ? (dealt / this.totalCards) * 100 : 0;
            }
        }

        function getHiLoValue(rank) {
            if (['2', '3', '4', '5', '6'].includes(rank)) return 1;
            if (['10', 'J', 'Q', 'K', 'A'].includes(rank)) return -1;
            return 0;
        }

        class HiLoCounter {
            constructor(numDecks = 6) {
                this.numDecks = numDecks;
                this.totalCards = numDecks * 52;
                this.reset();
            }
            reset() { this.runningCount = 0; this.cardsSeen = 0; }
            countCard(card) {
                this.countRank(card.rank);
            }
            countRank(rank) {
                this.cardsSeen++;
                this.runningCount += getHiLoValue(rank);
            }
            uncountCard(card) {
                this.uncountRank(card.rank);
            }
            uncountRank(rank) {
                this.cardsSeen--;
                this.runningCount -= getHiLoValue(rank);
            }
            getTrueCount() {
                const decksRemaining = (this.totalCards - this.cardsSeen) / 52;
                return decksRemaining > 0 ? this.runningCount / decksRemaining : 0;
            }
        }
        
        // ========================================================================
        // AI: EXACT EV DECISION ENGINE
        // ========================================================================
        const H = 'HIT', S = 'STAND', D = 'DOUBLE', P = 'SPLIT', R = 'SURRENDER';

        function getTrueCountFromState(countState, shoe) {
            const decksRemaining = shoe.cardsRemaining / 52;
            return decksRemaining > 0 ? countState.runningCount / decksRemaining : 0;
        }

        function isSurrenderAllowed(hand, rules) {
            return rules.surrenderType !== 'none' && hand.cards.length === 2 && !hand.fromSplit;
        }

        function canDouble(hand, rules) {
            if (hand.cards.length !== 2) return false;
            if (hand.fromSplit && !rules.doubleAfterSplit) return false;
            return true;
        }

        function canSplitHand(hand, currentHandCount, rules) {
            if (!hand.isPair() || hand.cards.length !== 2) return false;
            if (currentHandCount >= rules.maxHands) return false;
            const rank = hand.cards[0].rank;
            if (rank === 'A' && hand.isSplitAce && !rules.resplitAces) return false;
            return true;
        }

        function cloneHandForSimulation(hand) {
            const cloned = new Hand();
            cloned.cards = hand.cards.map(c => new Card(c.suit, c.rank));
            cloned.status = hand.status;
            cloned.fromSplit = hand.fromSplit;
            cloned.splitDepth = hand.splitDepth;
            cloned.isSplitAce = hand.isSplitAce;
            return cloned;
        }

        function getDealerBlackjackProb(dealerUpCard, shoe) {
            if (dealerUpCard.rank === 'A') {
                const tens = ['10', 'J', 'Q', 'K'].reduce((sum, r) => sum + (shoe.counts[r] || 0), 0);
                return shoe.cardsRemaining > 0 ? tens / shoe.cardsRemaining : 0;
            }
            if (['10', 'J', 'Q', 'K'].includes(dealerUpCard.rank)) {
                const aces = shoe.counts['A'] || 0;
                return shoe.cardsRemaining > 0 ? aces / shoe.cardsRemaining : 0;
            }
            return 0;
        }

        function shouldTakeInsurance(dealerUpCard, shoe) {
            const pDealerBJ = getDealerBlackjackProb(dealerUpCard, shoe);
            return pDealerBJ > (1 / 3);
        }

        // ========================================================================
        // EXACT EV CALCULATOR (COMPOSITION-DEPENDENT, DETERMINISTIC)
        // ========================================================================
        function getRankValue(rank) {
            if (['J', 'Q', 'K'].includes(rank)) return 10;
            if (rank === 'A') return 11;
            return parseInt(rank, 10);
        }

        function getRulesKey(rules) {
            return [
                rules.surrenderType,
                rules.dealerHitsOnSoft17 ? 1 : 0,
                rules.doubleAfterSplit ? 1 : 0,
                rules.resplitAces ? 1 : 0,
                rules.hitSplitAces ? 1 : 0,
                rules.blackjackPayout,
                rules.maxHands,
            ].join('|');
        }

        function getShoeKey(shoe) {
            return RANKS.map(rank => shoe.counts[rank] || 0).join(',');
        }

        function getHandKey(hand) {
            const counts = RANKS.map(rank => hand.cards.filter(c => c.rank === rank).length);
            return [
                counts.join(','),
                hand.cards.length,
                hand.fromSplit ? 1 : 0,
                hand.isSplitAce ? 1 : 0,
                hand.splitDepth,
            ].join('|');
        }

        function addRankToTotals(total, softAces, rank) {
            let nextTotal = total + getRankValue(rank);
            let nextSoftAces = softAces + (rank === 'A' ? 1 : 0);
            while (nextTotal > 21 && nextSoftAces > 0) {
                nextTotal -= 10;
                nextSoftAces -= 1;
            }
            return { total: nextTotal, softAces: nextSoftAces };
        }

        function mergeProbMaps(target, source, weight) {
            Object.keys(source).forEach(key => {
                target[key] = (target[key] || 0) + source[key] * weight;
            });
        }

        function getDealerOutcomeProbs(dealerUpCard, shoe, rules, dealerCache) {
            function dealerProbs(total, softAces, cardsCount) {
                const cacheKey = `${total}|${softAces}|${cardsCount}|${getShoeKey(shoe)}`;
                if (dealerCache.has(cacheKey)) return dealerCache.get(cacheKey);

                const result = {};
                if (cardsCount === 2 && total === 21) {
                    result.blackjack = 1;
                    dealerCache.set(cacheKey, result);
                    return result;
                }
                if (total > 21) {
                    result.bust = 1;
                    dealerCache.set(cacheKey, result);
                    return result;
                }

                const isSoft = softAces > 0;
                const shouldStand = total > 17 || (total === 17 && (!isSoft || !rules.dealerHitsOnSoft17));
                if (shouldStand) {
                    result[total] = 1;
                    dealerCache.set(cacheKey, result);
                    return result;
                }

                if (shoe.cardsRemaining <= 0) {
                    result[total] = 1;
                    dealerCache.set(cacheKey, result);
                    return result;
                }

                const remaining = shoe.cardsRemaining;
                RANKS.forEach(rank => {
                    const count = shoe.counts[rank] || 0;
                    if (count <= 0) return;
                    const prob = count / remaining;
                    shoe.drawRank(rank);
                    const next = addRankToTotals(total, softAces, rank);
                    const sub = dealerProbs(next.total, next.softAces, cardsCount + 1);
                    mergeProbMaps(result, sub, prob);
                    shoe.returnRank(rank);
                });

                dealerCache.set(cacheKey, result);
                return result;
            }

            const upRank = dealerUpCard.rank;
            const initial = addRankToTotals(0, 0, upRank);
            return dealerProbs(initial.total, initial.softAces, 1);
        }

        function getStandEV(hand, dealerUpCard, shoe, rules, dealerCache) {
            if (hand.isBust()) return -1;
            const dealerProbs = getDealerOutcomeProbs(dealerUpCard, shoe, rules, dealerCache);
            const pDealerBJ = dealerProbs.blackjack || 0;

            if (hand.isBlackjack() && !hand.fromSplit) {
                return (1 - pDealerBJ) * rules.blackjackPayout;
            }

            let ev = 0;
            Object.entries(dealerProbs).forEach(([outcome, prob]) => {
                if (outcome === 'blackjack') {
                    ev += -1 * prob;
                    return;
                }
                if (outcome === 'bust') {
                    ev += 1 * prob;
                    return;
                }
                const dealerTotal = parseInt(outcome, 10);
                const playerTotal = hand.getValue();
                if (playerTotal > dealerTotal) ev += 1 * prob;
                else if (playerTotal < dealerTotal) ev += -1 * prob;
                else ev += 0;
            });
            return ev;
        }

        function getOptimalEV(hand, dealerUpCard, shoe, rules, currentHandCount, caches) {
            if (hand.isBust()) return -1;
            if (hand.isSplitAce && !rules.hitSplitAces && hand.cards.length >= 2) {
                return getStandEV(hand, dealerUpCard, shoe, rules, caches.dealerCache);
            }
            if (hand.getValue() >= 21) {
                return getStandEV(hand, dealerUpCard, shoe, rules, caches.dealerCache);
            }

            const cacheKey = [
                getHandKey(hand),
                dealerUpCard.rank,
                getShoeKey(shoe),
                rules.cacheKey,
                currentHandCount,
            ].join('|');
            if (caches.handEvCache.has(cacheKey)) return caches.handEvCache.get(cacheKey);

            const legalMoves = [H, S];
            if (canDouble(hand, rules)) legalMoves.push(D);
            if (canSplitHand(hand, currentHandCount, rules)) legalMoves.push(P);
            if (isSurrenderAllowed(hand, rules)) legalMoves.push(R);

            let bestEV = -Infinity;
            legalMoves.forEach(move => {
                const ev = getActionEVExact(move, hand, dealerUpCard, shoe, rules, currentHandCount, caches);
                if (ev > bestEV) bestEV = ev;
            });

            caches.handEvCache.set(cacheKey, bestEV);
            return bestEV;
        }

        function getSplitEVExact(hand, dealerUpCard, shoe, rules, currentHandCount, caches) {
            // Note: split EV treats each hand independently after the initial two cards.
            const rank = hand.cards[0].rank;
            const splitDepth = hand.splitDepth + 1;

            const baseHand1 = new Hand();
            baseHand1.addCard(new Card('♠', rank));
            baseHand1.fromSplit = true;
            baseHand1.splitDepth = splitDepth;
            baseHand1.isSplitAce = rank === 'A';

            const baseHand2 = new Hand();
            baseHand2.addCard(new Card('♠', rank));
            baseHand2.fromSplit = true;
            baseHand2.splitDepth = splitDepth;
            baseHand2.isSplitAce = rank === 'A';

            let totalEV = 0;
            if (shoe.cardsRemaining <= 1) return -1;

            const remainingBefore = shoe.cardsRemaining;
            RANKS.forEach(rank1 => {
                const count1 = shoe.counts[rank1] || 0;
                if (count1 <= 0) return;
                const p1 = count1 / remainingBefore;
                shoe.drawRank(rank1);

                const hand1 = cloneHandForSimulation(baseHand1);
                hand1.addCard(new Card('♠', rank1));

                const remainingAfterFirst = shoe.cardsRemaining;
                RANKS.forEach(rank2 => {
                    const count2 = shoe.counts[rank2] || 0;
                    if (count2 <= 0) return;
                    const p2 = count2 / remainingAfterFirst;
                    shoe.drawRank(rank2);

                    const hand2 = cloneHandForSimulation(baseHand2);
                    hand2.addCard(new Card('♠', rank2));

                    const nextHandCount = currentHandCount + 1;
                    const ev1 = getOptimalEV(hand1, dealerUpCard, shoe, rules, nextHandCount, caches);
                    const ev2 = getOptimalEV(hand2, dealerUpCard, shoe, rules, nextHandCount, caches);
                    totalEV += p1 * p2 * (ev1 + ev2);

                    shoe.returnRank(rank2);
                });

                shoe.returnRank(rank1);
            });

            return totalEV;
        }

        function getActionEVExact(action, hand, dealerUpCard, shoe, rules, currentHandCount, caches) {
            if (action === S) {
                return getStandEV(hand, dealerUpCard, shoe, rules, caches.dealerCache);
            }
            if (action === R) {
                if (!isSurrenderAllowed(hand, rules)) return -Infinity;
                if (rules.surrenderType === 'early') return -0.5;
                const dealerProbs = getDealerOutcomeProbs(dealerUpCard, shoe, rules, caches.dealerCache);
                const pDealerBJ = dealerProbs.blackjack || 0;
                return -(pDealerBJ * 1 + (1 - pDealerBJ) * 0.5);
            }
            if (action === D) {
                if (!canDouble(hand, rules)) return -Infinity;
                let ev = 0;
                const remaining = shoe.cardsRemaining;
                if (remaining <= 0) return getStandEV(hand, dealerUpCard, shoe, rules, caches.dealerCache) * 2;
                RANKS.forEach(rank => {
                    const count = shoe.counts[rank] || 0;
                    if (count <= 0) return;
                    const prob = count / remaining;
                    shoe.drawRank(rank);
                    const newHand = cloneHandForSimulation(hand);
                    newHand.addCard(new Card('♠', rank));
                    ev += prob * (2 * getStandEV(newHand, dealerUpCard, shoe, rules, caches.dealerCache));
                    shoe.returnRank(rank);
                });
                return ev;
            }
            if (action === P) {
                if (!canSplitHand(hand, currentHandCount, rules)) return -Infinity;
                return getSplitEVExact(hand, dealerUpCard, shoe, rules, currentHandCount, caches);
            }

            // HIT
            let ev = 0;
            const remaining = shoe.cardsRemaining;
            if (remaining <= 0) return getStandEV(hand, dealerUpCard, shoe, rules, caches.dealerCache);
            RANKS.forEach(rank => {
                const count = shoe.counts[rank] || 0;
                if (count <= 0) return;
                const prob = count / remaining;
                shoe.drawRank(rank);
                const newHand = cloneHandForSimulation(hand);
                newHand.addCard(new Card('♠', rank));
                ev += prob * getOptimalEV(newHand, dealerUpCard, shoe, rules, currentHandCount, caches);
                shoe.returnRank(rank);
            });
            return ev;
        }

        function getRecommendedMoveExact(playerHand, dealerUpCard, gameRules, shoe, currentHandCount) {
            const legalMoves = [H, S];
            if (canDouble(playerHand, gameRules)) legalMoves.push(D);
            if (canSplitHand(playerHand, currentHandCount, gameRules)) legalMoves.push(P);
            if (isSurrenderAllowed(playerHand, gameRules)) legalMoves.push(R);

            const caches = {
                handEvCache: new Map(),
                dealerCache: new Map(),
            };

            const evs = {};
            legalMoves.forEach(move => {
                evs[move] = getActionEVExact(move, playerHand, dealerUpCard, shoe, gameRules, currentHandCount, caches);
            });

            let bestMove = legalMoves[0];
            legalMoves.forEach(move => {
                if (evs[move] > evs[bestMove]) bestMove = move;
            });

            return { move: bestMove, evs };
        }
        function getRecommendedMove(playerHand, dealerUpCard, gameRules, shoe, currentHandCount) {
            return getRecommendedMoveExact(playerHand, dealerUpCard, gameRules, shoe, currentHandCount);
        }

        function getBetAmount(counter, minBet, maxBet, bankroll) {
            const trueCount = counter.getTrueCount();
            let betUnits = 1;
            if (trueCount >= 4) betUnits = 8;
            else if (trueCount >= 3) betUnits = 6;
            else if (trueCount >= 2) betUnits = 4;
            else if (trueCount >= 1) betUnits = 2;
            const calculatedBet = betUnits * minBet;
            const finalBet = Math.min(calculatedBet, maxBet, bankroll * 0.25, bankroll);
            return Math.max(finalBet, minBet);
        }

        // ========================================================================
        // MAIN APPLICATION CONTROLLER
        // ========================================================================
        document.addEventListener('DOMContentLoaded', () => {
            const setupScreen = document.getElementById('setup-screen');
            const gameScreen = document.getElementById('game-screen');
            const recommendationText = document.getElementById('recommendation-text');
            const recommendationEv = document.getElementById('recommendation-ev');
            const currentActionText = document.getElementById('current-action');
            const playersArea = document.getElementById('players-area');
            const startGameBtn = document.getElementById('start-game-btn');
            const nextHandBtn = document.getElementById('next-hand-btn');
            const cancelActionBtn = document.getElementById('cancel-action-btn');
            const userActionButtons = document.querySelectorAll('.action-btn');
            const insurancePrompt = document.getElementById('insurance-prompt');
            const insuranceRecommendation = document.getElementById('insurance-recommendation');
            const cardsRemainingSpan = document.getElementById('cards-remaining');
            const cardPickerGrid = document.getElementById('card-picker-grid');
            
            // Setup Screen Controls
            const numPlayersInput = document.getElementById('num-players');
            const bankrollTypeRadios = document.querySelectorAll('input[name="bankroll-type"]');

            let players = [], dealer = new Player('Dealer'), counter, shoe, gameState = 'SETUP';
            let currentPlayerIndex = 0, currentHandIndex = 0, dealingQueue = [];
            let gameRules = {};
            let previousStateStack = [];
            
            // --- Setup Screen Logic ---
            function updateBankrollSetupUI() {
                const container = document.getElementById('bankroll-inputs-container');
                const numPlayers = parseInt(numPlayersInput.value, 10) || 1;
                const isIndividual = document.getElementById('bankroll-individual').checked;
                container.innerHTML = ''; // Clear previous inputs

                if (isIndividual) {
                    for (let i = 0; i < numPlayers; i++) {
                        const div = document.createElement('div');
                        div.className = 'setup-option';
                        div.innerHTML = `
                            <label for="initial-bankroll-${i}">Player ${i + 1} Bankroll:</label>
                            <input type="number" id="initial-bankroll-${i}" value="1000" min="1">
                        `;
                        container.appendChild(div);
                    }
                } else {
                    const div = document.createElement('div');
                    div.className = 'setup-option';
                    div.innerHTML = `
                        <label for="initial-bankroll">Initial Bankroll for All:</label>
                        <input type="number" id="initial-bankroll" value="1000" min="1">
                    `;
                    container.appendChild(div);
                }
            }
            
            numPlayersInput.addEventListener('input', updateBankrollSetupUI);
            bankrollTypeRadios.forEach(radio => radio.addEventListener('change', updateBankrollSetupUI));
            updateBankrollSetupUI(); // Initial call to populate the form

            startGameBtn.addEventListener('click', initializeGame);
            nextHandBtn.addEventListener('click', startNewHand);
            userActionButtons.forEach(button => button.addEventListener('click', e => handleActionButtonClick(e.target.dataset.move)));
            cancelActionBtn.addEventListener('click', () => {
                if (previousStateStack.length === 0) return;
                const snapshot = previousStateStack.pop();
                restoreGameSnapshot(snapshot);
                cancelActionBtn.disabled = previousStateStack.length === 0;
            });
            
            playersArea.addEventListener('click', (event) => {
                if (event.target.classList.contains('add-player-btn')) {
                    addNewPlayer(parseInt(event.target.dataset.seatIndex, 10));
                } else if (event.target.classList.contains('remove-player-btn')) {
                    removePlayer(parseInt(event.target.dataset.seatIndex, 10));
                } else if (event.target.classList.contains('update-bankroll-btn')) {
                    const index = parseInt(event.target.dataset.playerIndex, 10);
                    const inputEl = playersArea.querySelector(`.bankroll-input[data-player-index="${index}"]`);
                    if (players[index] && inputEl) {
                        savePreviousState();
                        const newBankroll = parseInt(inputEl.value, 10);
                        if (!isNaN(newBankroll) && newBankroll >= 0) {
                            players[index].bankroll = newBankroll;
                            updateUI(); // Refresh UI to show updated value
                        }
                    }
                }
            });

            function savePreviousState() {
                previousStateStack.push(getGameSnapshot());
                cancelActionBtn.disabled = previousStateStack.length === 0;
            }

            function getGameSnapshot() {
                return {
                    gameState,
                    currentPlayerIndex,
                    currentHandIndex,
                    dealingQueue: dealingQueue.map(item => ({ ...item })),
                    gameRules: { ...gameRules },
                    counter: counter ? {
                        numDecks: counter.numDecks,
                        runningCount: counter.runningCount,
                        cardsSeen: counter.cardsSeen,
                    } : null,
                    shoe: shoe ? {
                        numDecks: shoe.numDecks,
                        penetration: shoe.penetration,
                        counts: { ...shoe.counts },
                        cardsRemaining: shoe.cardsRemaining,
                        cutCardPosition: shoe.cutCardPosition,
                    } : null,
                    players: players.map(player => player ? serializePlayer(player) : null),
                    dealer: dealer ? serializePlayer(dealer) : null,
                    ui: {
                        recommendationText: recommendationText.textContent,
                        recommendationEv: recommendationEv.textContent,
                        currentActionText: currentActionText.textContent,
                        insurancePromptDisplay: insurancePrompt.style.display,
                        insuranceRecommendation: insuranceRecommendation.textContent,
                        nextHandBtnDisplay: nextHandBtn.style.display,
                        setupScreenDisplay: setupScreen.style.display,
                        gameScreenDisplay: gameScreen.style.display,
                    },
                };
            }

            function restoreGameSnapshot(snapshot) {
                gameState = snapshot.gameState;
                currentPlayerIndex = snapshot.currentPlayerIndex;
                currentHandIndex = snapshot.currentHandIndex;
                dealingQueue = snapshot.dealingQueue.map(item => ({ ...item }));
                gameRules = { ...snapshot.gameRules };

                if (snapshot.counter) {
                    counter = new HiLoCounter(snapshot.counter.numDecks);
                    counter.runningCount = snapshot.counter.runningCount;
                    counter.cardsSeen = snapshot.counter.cardsSeen;
                } else {
                    counter = null;
                }

                if (snapshot.shoe) {
                    shoe = new Shoe(snapshot.shoe.numDecks, snapshot.shoe.penetration);
                    shoe.counts = { ...snapshot.shoe.counts };
                    shoe.cardsRemaining = snapshot.shoe.cardsRemaining;
                    shoe.cutCardPosition = snapshot.shoe.cutCardPosition;
                } else {
                    shoe = null;
                }

                players = snapshot.players.map(player => player ? restorePlayer(player) : null);
                dealer = snapshot.dealer ? restorePlayer(snapshot.dealer) : new Player('Dealer');

                recommendationText.textContent = snapshot.ui.recommendationText;
                recommendationEv.textContent = snapshot.ui.recommendationEv;
                currentActionText.textContent = snapshot.ui.currentActionText;
                insurancePrompt.style.display = snapshot.ui.insurancePromptDisplay;
                insuranceRecommendation.textContent = snapshot.ui.insuranceRecommendation;
                nextHandBtn.style.display = snapshot.ui.nextHandBtnDisplay;
                setupScreen.style.display = snapshot.ui.setupScreenDisplay;
                gameScreen.style.display = snapshot.ui.gameScreenDisplay;

                createPlayerUI();
                updateUI();
            }

            function serializePlayer(player) {
                return {
                    id: player.id,
                    bankroll: player.bankroll,
                    hands: player.hands.map(hand => ({
                        cards: hand.cards.map(card => ({ rank: card.rank, suit: card.suit })),
                        status: hand.status,
                        fromSplit: hand.fromSplit,
                        splitDepth: hand.splitDepth,
                        isSplitAce: hand.isSplitAce,
                    })),
                    bets: [...player.bets],
                    status: player.status,
                };
            }

            function restorePlayer(data) {
                const player = new Player(data.id, data.bankroll);
                player.bankroll = data.bankroll;
                player.hands = data.hands.map(handData => {
                    const hand = new Hand();
                    hand.cards = handData.cards.map(card => new Card(card.suit, card.rank));
                    hand.status = handData.status;
                    hand.fromSplit = handData.fromSplit;
                    hand.splitDepth = handData.splitDepth;
                    hand.isSplitAce = handData.isSplitAce;
                    return hand;
                });
                player.bets = [...data.bets];
                player.status = data.status;
                return player;
            }

            function addNewPlayer(seatIndex) {
                savePreviousState();
                // Find the first individual bankroll input to get a default value
                const defaultBankrollEl = document.getElementById('initial-bankroll-0') || document.getElementById('initial-bankroll');
                const initialBankroll = defaultBankrollEl ? (parseInt(defaultBankrollEl.value, 10) || 1000) : 1000;
                
                players[seatIndex] = new Player(`Player ${seatIndex + 1}`, initialBankroll);

                if (gameState === 'BETTING') {
                    const newPlayer = players[seatIndex];
                    const betAmount = getBetAmount(counter, gameRules.minBet, gameRules.maxBet, newPlayer.bankroll);
                    newPlayer.bets[0] = betAmount;
                    newPlayer.bankroll -= betAmount;
                    buildDealingQueue();
                    if (dealingQueue.length > 0) {
                        currentActionText.textContent = dealingQueue[0].message;
                    }
                }
                createPlayerUI();
                updateUI();
            }

            function removePlayer(seatIndex) {
                const playerToRemove = players[seatIndex];
                if (!playerToRemove) return;
                if (gameState !== 'BETTING' && gameState !== 'SETTLEMENT') return;

                savePreviousState();
                const betAmount = playerToRemove.bets.reduce((sum, bet) => sum + bet, 0);
                playerToRemove.bankroll += betAmount;
                players[seatIndex] = null;

                buildDealingQueue();
                currentActionText.textContent = dealingQueue.length > 0 ? dealingQueue[0].message : 'All players left. Add a player to begin.';
                
                createPlayerUI();
                updateUI();
            }

            function initializeGame() {
                const numPlayers = parseInt(numPlayersInput.value, 10);
                const numDecks = parseInt(document.getElementById('num-decks').value, 10);
                const minBet = parseInt(document.getElementById('min-bet').value, 10);
                const maxBetInput = document.getElementById('max-bet').value;
                const maxBet = maxBetInput ? parseInt(maxBetInput, 10) : Infinity;
                const cutCardPercent = parseInt(document.getElementById('cut-card-penetration').value, 10);
                gameRules = { 
                    minBet,
                    maxBet,
                    surrenderType: document.getElementById('surrender-type').value,
                    dealerHitsOnSoft17: document.getElementById('soft-17-rule').value === 'hit',
                    doubleAfterSplit: document.getElementById('allow-das').checked,
                    resplitAces: document.getElementById('allow-resplit-aces').checked,
                    hitSplitAces: document.getElementById('hit-split-aces').checked,
                    blackjackPayout: parseFloat(document.getElementById('blackjack-payout').value),
                    cutCardPenetration: isNaN(cutCardPercent) ? 0.75 : Math.min(Math.max(cutCardPercent / 100, 0.5), 0.95),
                    maxHands: 4,
                };
                gameRules.cacheKey = getRulesKey(gameRules);

                counter = new HiLoCounter(numDecks);
                shoe = new Shoe(numDecks, gameRules.cutCardPenetration);
                
                // Initialize players with correct bankrolls based on setup choice
                const isIndividual = document.getElementById('bankroll-individual').checked;
                players = Array.from({ length: numPlayers }, (_, i) => {
                    let bankroll;
                    if (isIndividual) {
                        const inputEl = document.getElementById(`initial-bankroll-${i}`);
                        bankroll = inputEl ? parseInt(inputEl.value, 10) : 1000;
                    } else {
                        const inputEl = document.getElementById('initial-bankroll');
                        bankroll = inputEl ? parseInt(inputEl.value, 10) : 1000;
                    }
                    return new Player(`Player ${i + 1}`, bankroll || 1000);
                });

                dealer = new Player('Dealer');
                
                document.querySelector('[data-move="SURRENDER"]').style.display = gameRules.surrenderType !== 'none' ? 'inline-block' : 'none';
                setupScreen.style.display = 'none';
                gameScreen.style.display = 'grid';
                createCardPicker();
                startNewHand();
            }
            
            function createCardPicker() {
                cardPickerGrid.innerHTML = '';
                RANKS.forEach(rank => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card-picker-card';
                    cardEl.textContent = rank;
                    cardEl.dataset.rank = rank;
                    cardEl.addEventListener('click', () => handleCardPickerClick(rank));
                    cardPickerGrid.appendChild(cardEl);
                });
            }

            function handleHandClick(event) {
                const handEl = event.currentTarget;
                const pIndex = parseInt(handEl.dataset.pIndex, 10);
                const hIndex = parseInt(handEl.dataset.hIndex, 10);

                if (pIndex !== currentPlayerIndex || gameState !== 'PLAYER_TURN') return;
                
                const hand = players[pIndex].hands[hIndex];
                if (hand.status !== 'active') return; 

                currentHandIndex = hIndex;
                startPlayerTurn();
            }

            function handleCardPickerClick(rank) {
                if (!shoe || !shoe.canDraw(rank)) return;
                savePreviousState();
                if (gameState === 'BETTING') {
                    gameState = 'DEALING';
                }

                const cardToDeal = new Card('♠', rank);
                shoe.drawRank(rank);
                counter.countRank(rank);
                if (gameState === 'DEALING') {
                    const dealInfo = dealingQueue.shift();
                    if (!dealInfo) return;
                    const target = dealInfo.isDealer ? dealer : players[dealInfo.playerIndex];
                    target.hands[dealInfo.handIndex || 0].addCard(cardToDeal);
                    processDealingQueue();
                } else if (gameState === 'PLAYER_TURN') {
                    const hand = players[currentPlayerIndex].hands[currentHandIndex];
                    hand.addCard(cardToDeal);
                    if (hand.isSplitAce && !gameRules.hitSplitAces && hand.cards.length >= 2) {
                        hand.status = 'stand';
                        advanceTurn();
                    } else if (hand.status === 'doubled' || hand.getValue() >= 21) {
                        if (hand.isBust()) hand.status = 'bust';
                        else if (hand.getValue() === 21) {
                            hand.status = hand.isBlackjack() && !hand.fromSplit ? 'blackjack' : 'stand';
                        }
                        advanceTurn();
                    } else { startPlayerTurn(); }
                } else if (gameState === 'DEALER_TURN') {
                    dealer.hands[0].addCard(cardToDeal);
                    startDealerTurn(); 
                }
            }
            
            function handleActionButtonClick(move) {
                const player = players[currentPlayerIndex];
                if (!player || gameState !== 'PLAYER_TURN') return;
                const hand = player.hands[currentHandIndex];
                if (!hand) return;
                
                savePreviousState();
                switch (move) {
                    case 'HIT':
                        currentActionText.textContent = `Player hits on Hand ${currentHandIndex + 1}. Select dealt card.`;
                        break;
                    case 'STAND': hand.status = 'stand'; advanceTurn(); break;
                    case 'DOUBLE':
                        if (!canDouble(hand, gameRules)) {
                            recommendationText.textContent = "Double not allowed.";
                            break;
                        }
                        if (player.bankroll < player.bets[currentHandIndex]) {
                            recommendationText.textContent = "Insufficient bankroll to double.";
                            break;
                        }
                        player.bankroll -= player.bets[currentHandIndex];
                        player.bets[currentHandIndex] *= 2;
                        hand.status = 'doubled';
                        currentActionText.textContent = `Player doubled on Hand ${currentHandIndex + 1}. Deal ONE card.`;
                        break;
                    case 'SPLIT':
                        if (!canSplitHand(hand, player.hands.length, gameRules)) {
                            recommendationText.textContent = "Split not allowed.";
                            break;
                        }
                        if (player.bankroll < player.bets[currentHandIndex]) {
                            recommendationText.textContent = "Insufficient bankroll to split.";
                            break;
                        }
                        player.bankroll -= player.bets[currentHandIndex];
                        player.splitHand(currentHandIndex);
                        startPlayerTurn();
                        break;
                    case 'SURRENDER':
                        if (isSurrenderAllowed(hand, gameRules)) { hand.status = 'surrendered'; advanceTurn(); } 
                        else { recommendationText.textContent = "Cannot surrender now."; }
                        break;
                }
                updateUI();
            }

            function startNewHand() {
                savePreviousState();
                gameState = 'BETTING';
                nextHandBtn.style.display = 'none'; insurancePrompt.style.display = 'none';
                if (shoe && shoe.shouldShuffle()) {
                    shoe.reset();
                    if (counter) counter.reset();
                }
                players.forEach(p => { if (p) p.reset(); });
                dealer.reset();
                createPlayerUI();
                recommendationText.textContent = '---';
                recommendationEv.textContent = 'EVs: --';

                players.forEach((p, i) => { 
                    if (!p) return;
                    const betAmount = getBetAmount(counter, gameRules.minBet, gameRules.maxBet, p.bankroll);
                    p.bets[0] = betAmount; 
                    p.bankroll -= betAmount;
                    const playerCard = document.getElementById(`player-${p.id.replace(/ /g, '-')}`);
                    if(playerCard) {
                        const recElement = playerCard.querySelector('.player-bet-recommendation');
                        if (recElement) recElement.textContent = `AI Recommended Bet: ${betAmount}`;
                    }
                });
                buildDealingQueue();
                processDealingQueue();
                updateUI(); 
            }

            function buildDealingQueue() {
                dealingQueue = [];
                players.forEach((p, i) => { if (p) dealingQueue.push({ playerIndex: i, handIndex: 0, message: `Deal first card to Player ${i + 1}` }); });
                dealingQueue.push({ isDealer: true, message: `Deal dealer's UP card` });
                players.forEach((p, i) => { if (p) dealingQueue.push({ playerIndex: i, handIndex: 0, message: `Deal second card to Player ${i + 1}` }); });
            }

            function processDealingQueue() {
                if (dealingQueue.length > 0) {
                    currentActionText.textContent = dealingQueue[0].message;
                    updateUI();
                } else { 
                    postDealCheck(); 
                }
            }

            function postDealCheck() {
                if (dealer.hands[0].cards.length > 0 && dealer.hands[0].cards[0].rank === 'A') {
                    insurancePrompt.style.display = 'block';
                    insuranceRecommendation.textContent = shouldTakeInsurance(dealer.hands[0].cards[0], shoe) ? "TAKE Insurance" : "DO NOT Take Insurance";
                }
                currentPlayerIndex = 0; currentHandIndex = 0;
                startPlayerTurn();
            }

            function startPlayerTurn() {
                while(currentPlayerIndex < players.length && !players[currentPlayerIndex]) {
                    currentPlayerIndex++;
                }

                if (currentPlayerIndex >= players.length) { startDealerTurn(); return; }
                
                gameState = 'PLAYER_TURN';
                const player = players[currentPlayerIndex];
                const hand = player.hands[currentHandIndex];
                
                updateUI(); 

                if(!hand || hand.status !== 'active') { advanceTurn(); return; }
                
                if (hand.cards.length === 1) { 
                    currentActionText.textContent = `Player ${player.id}, Hand ${currentHandIndex + 1}: Please deal a card.`;
                    return;
                }
                
                if (hand.getValue() >= 21) {
                    if (hand.isBlackjack() && !hand.fromSplit) hand.status = 'blackjack';
                    else if (hand.isBust()) hand.status = 'bust';
                    else hand.status = 'stand';
                    advanceTurn(); return;
                }

                const rec = getRecommendedMove(hand, dealer.hands[0].cards[0], gameRules, shoe, player.hands.length);
                recommendationText.textContent = `AI recommends: ${rec.move}`;
                const evSummary = Object.entries(rec.evs)
                    .map(([move, ev]) => `${move}: ${ev.toFixed(3)}`)
                    .join(' | ');
                recommendationEv.textContent = `EVs: ${evSummary}`;
                currentActionText.textContent = `Player ${player.id}, Hand ${currentHandIndex + 1}: Waiting for user action.`;
            }
            
            function advanceTurn() {
                const player = players[currentPlayerIndex];
                if (!player) { 
                    startDealerTurn(); 
                    return; 
                }

                const nextActiveHandIndex = player.hands.findIndex(hand => hand.status === 'active');

                if (nextActiveHandIndex !== -1) {
                    currentHandIndex = nextActiveHandIndex;
                    startPlayerTurn();
                } else {
                    currentPlayerIndex++;
                    currentHandIndex = 0;
                    startPlayerTurn(); 
                }
            }

            function startDealerTurn() {
                gameState = 'DEALER_TURN';
                recommendationText.textContent = '---';
                if (dealer.hands[0].cards.length < 2) {
                    currentActionText.textContent = `All players finished. Deal dealer's hole card.`;
                } else {
                    const dealerHand = dealer.hands[0];
                    const dealerValue = dealerHand.getValue();
                    let dealerStands = false;
                    if (dealerValue > 17 || (dealerValue === 17 && !dealerHand.isSoft()) || (dealerValue === 17 && dealerHand.isSoft() && !gameRules.dealerHitsOnSoft17)) {
                        dealerStands = true;
                    }

                    if (dealerHand.isBlackjack()) {
                        currentActionText.textContent = `Dealer has Blackjack.`;
                        settleBets();
                    } else if (dealerHand.isBust()) {
                         currentActionText.textContent = `Dealer busts with ${dealerValue}.`;
                         settleBets();
                    }
                    else if (dealerStands) {
                        currentActionText.textContent = `Dealer stands with ${dealerValue}.`;
                        settleBets();
                    } else {
                        currentActionText.textContent = `Dealer hits. Input next dealer card.`;
                    }
                }
                updateUI();
            }

            function settleBets() {
                gameState = 'SETTLEMENT';
                const dealerHand = dealer.hands[0];
                const dealerValue = dealerHand.isBust() ? 0 : dealerHand.getValue();
                
                players.forEach((player, index) => {
                    if (!player) return;

                    let totalPayout = 0;
                    player.hands.forEach((hand, hIndex) => {
                        const bet = player.bets[hIndex];
                        if (hand.status === 'surrendered') {
                            if (gameRules.surrenderType === 'late' && dealerHand.isBlackjack()) {
                                totalPayout += 0;
                            } else {
                                totalPayout += bet / 2;
                            }
                            return;
                        }
                        if (hand.isBlackjack() && !hand.fromSplit) {
                            if (dealerHand.isBlackjack()) {
                                totalPayout += bet;
                                hand.status = "PUSH";
                            } else {
                                totalPayout += bet * (1 + gameRules.blackjackPayout);
                                hand.status = "WIN (BJ)";
                            }
                            return;
                        }
                        if (dealerHand.isBlackjack()) { hand.status = "LOSE"; return; }
                        const playerValue = hand.isBust() ? 0 : hand.getValue();
                        if (playerValue > 0 && (dealerValue === 0 || playerValue > dealerValue)) { totalPayout += bet * 2; hand.status = "WIN"; }
                        else if (playerValue > 0 && playerValue === dealerValue && !dealerHand.isBlackjack()) { totalPayout += bet; hand.status = "PUSH"; }
                        else { hand.status = "LOSE"; }
                    });
                    player.bankroll += totalPayout;

                    if (player.bankroll <= 0) {
                        console.log(`Player ${player.id} has busted out.`);
                        players[index] = null;
                    }
                });

                currentActionText.textContent = 'Bets settled. Empty seats are now open.';
                nextHandBtn.style.display = 'inline-block';
                
                createPlayerUI();
                updateUI();
            }
            
            function createPlayerUI() {
                playersArea.innerHTML = '';
                players.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-card';

                    if (player) {
                        playerDiv.id = `player-${player.id.replace(/ /g, '-')}`;
                        playerDiv.innerHTML = `
                            <button class="remove-player-btn" data-seat-index="${index}" title="Remove Player">✖</button>
                            <h3>${player.id}</h3>
                            <div class="player-bet-recommendation"></div>
                            <div class="player-hands-container"></div>
                            <p>
                                Bankroll: <span class="player-bankroll">${Math.round(player.bankroll)}</span>
                                <span class="bankroll-update-controls">
                                    <input type="number" class="bankroll-input" value="${Math.round(player.bankroll)}" data-player-index="${index}">
                                    <button class="update-bankroll-btn" data-player-index="${index}">Update</button>
                                </span>
                            </p>`;
                    } else {
                        playerDiv.classList.add('empty-seat');
                        playerDiv.id = `seat-${index}`;
                        playerDiv.innerHTML = `
                            <h3>Seat ${index + 1} (Empty)</h3>
                            <button class="add-player-btn" data-seat-index="${index}">Add New Player</button>
                        `;
                    }
                    playersArea.appendChild(playerDiv);
                });
            }

            function updateUI() {
                updateInfo();
                document.getElementById('dealer-value').textContent = dealer.hands[0].getValue();
                document.querySelector('#dealer-area #dealer-cards').innerHTML = dealer.hands[0].cards.map(c => `<span class="card">${c.rank}</span>`).join(' ');
                
                const showControls = (gameState === 'SETTLEMENT' || gameState === 'BETTING');

                players.forEach((player, pIndex) => {
                    if (!player) return;
                    const playerDiv = document.getElementById(`player-${player.id.replace(/ /g, '-')}`);
                    if (!playerDiv) return;
                    playerDiv.classList.toggle('active-player', pIndex === currentPlayerIndex && (gameState === 'PLAYER_TURN' || gameState === 'DEALING'));
                    playerDiv.querySelector('.player-bankroll').textContent = Math.round(player.bankroll);
                    
                    const updateControls = playerDiv.querySelector('.bankroll-update-controls');
                    if(updateControls) {
                        updateControls.style.display = showControls ? 'inline' : 'none';
                    }
                    
                    const handsContainer = playerDiv.querySelector('.player-hands-container');
                    handsContainer.innerHTML = player.hands.map((hand, hIndex) => {
                        const isPlayerTurn = pIndex === currentPlayerIndex && gameState === 'PLAYER_TURN';
                        const isPlayable = isPlayerTurn && hand.status === 'active';
                        const isActiveHand = isPlayable && hIndex === currentHandIndex;

                        return `
                        <div class="hand ${isActiveHand ? 'active-hand' : ''} ${isPlayable ? 'playable' : ''}" 
                             data-p-index="${pIndex}" data-h-index="${hIndex}">
                            <div>${hand.cards.map(c => `<span class="card">${c.rank}</span>`).join(' ')}</div>
                            <p>Bet: ${player.bets[hIndex]} | Val: ${hand.getValue()} | Status: <span class="player-status">${hand.status}</span></p>
                        </div>`;
                    }).join('');

                    handsContainer.querySelectorAll('.hand.playable').forEach(handEl => {
                        handEl.addEventListener('click', handleHandClick);
                    });
                });

                document.querySelectorAll('.remove-player-btn').forEach(btn => {
                    btn.style.display = showControls ? 'inline-block' : 'none';
                });

                if (shoe) {
                    cardPickerGrid.querySelectorAll('.card-picker-card').forEach(cardEl => {
                        const rank = cardEl.dataset.rank;
                        const remaining = shoe.counts[rank] || 0;
                        cardEl.classList.toggle('disabled', remaining <= 0);
                        cardEl.title = `${remaining} remaining`;
                    });
                }
            }

            function updateInfo() {
                if (!counter || !shoe) return;
                document.getElementById('info-value-1').textContent = counter.runningCount;
                document.getElementById('info-value-2').textContent = counter.getTrueCount().toFixed(1);
                cardsRemainingSpan.textContent = shoe.cardsRemaining;
                document.getElementById('penetration-value').textContent = `${shoe.getPenetrationPercent().toFixed(0)}%`;
            }
        });
    </script>

</body>
</html>
